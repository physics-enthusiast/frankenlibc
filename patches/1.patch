Submodule linux contains modified content
diff --git a/linux/arch/lkl/Makefile b/linux/arch/lkl/Makefile
index 41c61ca6d9a2..4b96c7591d11 100644
--- a/linux/arch/lkl/Makefile
+++ b/linux/arch/lkl/Makefile
@@ -22,7 +22,7 @@ $(error Unrecognized platform: $(OUTPUT_FORMAT))
 endif
 
 ifeq ($(OUTPUT_FORMAT),elf32-littlearm)
-CFLAGS_ABI      :=-mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp
+CFLAGS_ABI      :=-mabi=aapcs-linux -mno-thumb-interwork -marm -mfpu=vfp
 KBUILD_CFLAGS += $(CFLAGS_ABI)
 endif
 
diff --git a/linux/arch/lkl/include/asm/elf.h b/linux/arch/lkl/include/asm/elf.h
index b72ce226424b..f11bb31aaacd 100644
--- a/linux/arch/lkl/include/asm/elf.h
+++ b/linux/arch/lkl/include/asm/elf.h
@@ -3,8 +3,15 @@
 
 #include <asm/auxvec.h>
 
+#ifdef __x86_64__
 #define elf_check_arch(x) \
 	((x)->e_machine == EM_X86_64)
+#define ELF_PLATFORM "x86_64"
+#else
+#define elf_check_arch(x) \
+	((x)->e_machine == EM_AARCH64)
+#define ELF_PLATFORM "v7l"
+#endif
 
 /* XXX: should check e_flags */
 //#define elf_check_fdpic(x) 1
@@ -19,7 +26,6 @@
 
 #define ELF_EXEC_PAGESIZE	PAGE_SIZE
 /* XXX */
-#define ELF_PLATFORM "x86_64"
 #define ELF_HWCAP	0
 #define ELF_ET_DYN_BASE 0
 
diff --git a/linux/arch/lkl/include/asm/processor.h b/linux/arch/lkl/include/asm/processor.h
index 9a70cc72d6c5..98632f98761c 100644
--- a/linux/arch/lkl/include/asm/processor.h
+++ b/linux/arch/lkl/include/asm/processor.h
@@ -49,6 +49,10 @@ static inline void start_thread(struct pt_regs *regs, unsigned long pc,
 	asm("mov %0, %%rsp" :: "m"(sp));
 	asm("mov %0, %%rax" :: "m"(pc));
 	asm("jmp *%rax");
+#else
+        asm("mov sp, %0" :: "r"(sp));
+        asm("mov x0, %0" :: "r"(pc));
+        asm("br  x0");
 #endif
 }
 
diff --git a/linux/arch/lkl/include/asm/sched.h b/linux/arch/lkl/include/asm/sched.h
index 9fe6413b4e2e..efccb4842256 100644
--- a/linux/arch/lkl/include/asm/sched.h
+++ b/linux/arch/lkl/include/asm/sched.h
@@ -12,7 +12,7 @@ static inline void thread_sched_jb(void)
 		lkl_ops->jmp_buf_set(&current_thread_info()->sched_jb,
 				     schedule);
 	} else {
-		lkl_bug("thread_sched_jb() can be used only for host task");
+		lkl_bug("thread_sched_jb() can be used only for host task\n");
 	}
 }
 
diff --git a/linux/arch/lkl/include/asm/thread_info.h b/linux/arch/lkl/include/asm/thread_info.h
index c2488171e83b..56955a98784c 100644
--- a/linux/arch/lkl/include/asm/thread_info.h
+++ b/linux/arch/lkl/include/asm/thread_info.h
@@ -17,6 +17,7 @@ struct rump_sysproxy_info {
 	void *client;		/* client handle */
 	bool remote;		/* is remote syscall */
 	int count;		/* reentrancy count */
+  int execve;
 };
 
 struct thread_info {
diff --git a/linux/arch/lkl/include/uapi/asm/sigcontext.h b/linux/arch/lkl/include/uapi/asm/sigcontext.h
index a3c2a1b73084..4f16ddd74b11 100644
--- a/linux/arch/lkl/include/uapi/asm/sigcontext.h
+++ b/linux/arch/lkl/include/uapi/asm/sigcontext.h
@@ -9,6 +9,7 @@ struct lkl_pt_regs {
  * C ABI says these regs are callee-preserved. They aren't saved on kernel entry
  * unless syscall needs a complete, fully filled "struct pt_regs".
  */
+#ifdef __x86_64__
 	unsigned long r15;
 	unsigned long r14;
 	unsigned long r13;
@@ -37,6 +38,22 @@ struct lkl_pt_regs {
 	unsigned long sp;
 	unsigned long ss;
 /* top of stack page */
+#else
+  unsigned long x19;
+  unsigned long x20;
+  unsigned long x21;
+  unsigned long x22;
+  unsigned long x23;
+  unsigned long x24;
+  unsigned long x25;
+  unsigned long x26;
+  unsigned long x27;
+  unsigned long x28;
+  unsigned long fp; //x29
+  unsigned long lr; //x30
+  unsigned long sp;
+  unsigned long pc;
+#endif
 };
 
 struct pt_regs {
diff --git a/linux/arch/lkl/kernel/syscalls.c b/linux/arch/lkl/kernel/syscalls.c
index 2940c5a440f4..8c1e9c74a8da 100644
--- a/linux/arch/lkl/kernel/syscalls.c
+++ b/linux/arch/lkl/kernel/syscalls.c
@@ -102,7 +102,7 @@ static void del_host_task(void *arg)
 
 static struct lkl_tls_key *task_key;
 
-int inline lkl_save_register(struct task_struct *task)
+int /*inline*/ lkl_save_register(struct task_struct *task)
 {
 #ifdef __x86_64
 	/* XXX: proper way ? */
@@ -125,7 +125,23 @@ int inline lkl_save_register(struct task_struct *task)
 
 	return 0;
 #else
-	return -ENOSYS;
+	task_pt_regs(task)->regs.sp = (unsigned long)(__builtin_frame_address(0) + 16);
+	task_pt_regs(task)->regs.fp = (unsigned long)__builtin_frame_address(1);
+	task_pt_regs(task)->regs.pc = (unsigned long)__builtin_return_address(0);
+#define SAVE_REG(r)						\
+	asm("str "#r", %0" :: "m"(task_pt_regs(task)->regs.r));
+	SAVE_REG(x19);
+	SAVE_REG(x20);
+	SAVE_REG(x21);
+	SAVE_REG(x22);
+	SAVE_REG(x23);
+	SAVE_REG(x24);
+	SAVE_REG(x25);
+	SAVE_REG(x26);
+	SAVE_REG(x27);
+	SAVE_REG(x28);
+	SAVE_REG(lr);
+	return 0;
 #endif /* __x86_64 */
 }
 
@@ -171,25 +187,56 @@ long lkl_syscall(long no, long *params)
 	switch_to_host_task(task);
 
 	/* rentrant syscall */
-	if (task_thread_info(task)->rump.count)
+	if (task_thread_info(task)->rump.count) {
 		lkl_cpu_put();
+                if (task_thread_info(task)->rump.execve) {
+                  task_thread_info(task)->rump.execve = 0;
+                  task_thread_info(task)->rump.count--;
+                }
+        }
 
 	task_thread_info(task)->rump.count++;
 
 	if (no == __NR_vfork) {
-		ret = lkl_save_register(task);
+          struct task_struct *task2 = task;
+
+          #if 1
+          new_host_task(&task2);
+          switch_to_host_task(task2);
+          #endif
+          ret = lkl_save_register(task2);
+                if (ret > 0)
+                  return 0;
 		if (ret < 0)
 			return ret;
 	}
 
 #ifdef RUMPUSER
 	void rump_platform_exit(void);
-	if (no == __NR_exit || no == __NR_exit_group)
+        if (no == __NR_exit || no == __NR_exit_group) {
+          if (task_tgid_vnr(get_current()) == 1) {
 		rump_platform_exit();
+          } else {
+            struct thread_info *ti;
+            
+            /* mark forked task as dead */
+            ti = current_thread_info();
+            ti->dead = true;
+            lkl_ops->tls_set(task_key, NULL);
+          }
+        }
 #endif
 
+        if (no == __NR_execve) {
+          task_thread_info(task)->rump.execve = 1;
+        }
+
 	ret = run_syscall(no, params);
 
+        if (no == __NR_execve) {
+          task_thread_info(task)->rump.execve = 0;
+        }
+
 	/* rentrant syscall */
 	if (task_thread_info(task)->rump.count >= 2)
 		lkl_cpu_get();
diff --git a/linux/arch/lkl/kernel/threads.c b/linux/arch/lkl/kernel/threads.c
index 7688e62e7b24..4f6f680d36d9 100644
--- a/linux/arch/lkl/kernel/threads.c
+++ b/linux/arch/lkl/kernel/threads.c
@@ -18,7 +18,9 @@ static int init_ti(struct thread_info *ti)
 	ti->prev_sched = NULL;
 	ti->tid = 0;
 	ti->rump.client = NULL;
+        ti->rump.count = 0;
 	ti->rump.remote = false;
+	ti->rump.execve = 0;
 
 	return 0;
 }
@@ -114,7 +116,9 @@ struct task_struct *__switch_to(struct task_struct *prev,
 	if (test_bit(TIF_SCHED_JB, &_prev_flags)) {
 		lkl_ops->jmp_buf_longjmp(&_prev_jb, 1);
 	} else {
+          if (!_prev->dead) {
 		lkl_ops->sem_down(_prev->sched_sem);
+          }
 	}
 
 	if (_prev->dead)
@@ -150,6 +154,26 @@ struct thread_bootstrap_arg {
 	void *arg;
 };
 
+static void restore_register_sub(struct task_struct *task, unsigned long newsp, unsigned long newfp) {
+#define RESTORE_REG(r)				\
+	asm("ldr "#r", %0" :: "m"(task_pt_regs(task)->regs.r));
+        RESTORE_REG(lr);
+        RESTORE_REG(x28);
+        RESTORE_REG(x27);
+        RESTORE_REG(x26);
+        RESTORE_REG(x25);
+        RESTORE_REG(x24);
+        RESTORE_REG(x23);
+        RESTORE_REG(x22);
+        RESTORE_REG(x21);
+        RESTORE_REG(x20);
+        RESTORE_REG(x19);
+	asm("mov sp, %0" :: "r"(newsp));
+	asm("mov fp, %0" :: "r"(newfp));
+	asm("mov w0, #1");
+	asm("ret");
+}
+
 void inline lkl_restore_register(struct task_struct *task)
 {
 #ifdef __x86_64
@@ -185,6 +209,20 @@ void inline lkl_restore_register(struct task_struct *task)
 	/* case for (v)fork: child should return 0 */
 	asm("mov $0, %rax");
 	asm("jmp *%r10");
+#else
+	void *newsp;
+        unsigned long newfp;
+	unsigned long stack_size;
+#define FORK_STACK_SIZE 1200
+	stack_size = STACK_TOP - 8 - task_pt_regs(task)->regs.sp;
+	stack_size = stack_size > FORK_STACK_SIZE ? FORK_STACK_SIZE : stack_size;
+	pr_info("regs.sp=%lx, ssize=%lu\n", task_pt_regs(task)->regs.sp, stack_size);
+	newsp = kmalloc(stack_size, GFP_KERNEL);
+	pr_info("newsp=%lx\n", (unsigned long)newsp);
+	memcpy(newsp, (void *)task_pt_regs(task)->regs.sp, stack_size);
+	newfp = (unsigned long)newsp
+		+ (task_pt_regs(task)->regs.fp - task_pt_regs(task)->regs.sp);
+        restore_register_sub(task, (unsigned long)newsp, newfp);
 #endif /* __x86_64 */
 }
 
diff --git a/linux/tools/lkl/lib/rump-host.c b/linux/tools/lkl/lib/rump-host.c
index 97ffe497c0a2..01aa19a7a7ad 100644
--- a/linux/tools/lkl/lib/rump-host.c
+++ b/linux/tools/lkl/lib/rump-host.c
@@ -183,6 +183,11 @@ static int rump_tls_set(struct lkl_tls_key *key, void *data)
 	if (!new)
 		rumpuser_malloc(sizeof(struct lkl_tls_key), 0, (void **)&new);
 
+	if (!data) {
+		rumpuser_setcookie(NULL);
+		return 0;
+	}
+        
 	new->destructor = key->destructor;
 	new->data = data;
 	rumpuser_setcookie(new);
@@ -532,7 +537,8 @@ static void timer_free(void *_timer)
 
 static void panic(void)
 {
-	rumpuser_exit(RUMPUSER_PANIC);
+	*(volatile char *)0=0;
+        //	rumpuser_exit(RUMPUSER_PANIC);
 }
 
 struct lkl_host_operations lkl_host_ops = {
